===============================================================================
# N+1 problem in ORM (or O/R Mapper, OR/M)
* -> may occur when trying to **load data from a table along with its `related data`** having a **`one-to-many`** or **`many-to-many`** relationship (when the related data is on the many-side)
* -> có 2 nguyên nhân: **`a limitation, design flow in the O/R mapper itself`** and **`an inappropriate use of the O/R mapper itself`**

```cs
// Example 1: limitation of EntityFramework 2 - execute N+1 SQL statements with following LINQ query:
// -> 1 statement for loading N ProductGroups
// -> N statements for loading the Products
var groups = Context.ProductGroups
          .Where(g => g.Name.Contains("Group"))
          .Select(g => new
          {
            ProductGroup = g,
            Product = g.Products.FirstOrDefault()
          })
          .ToList();
```

```cs
// Example 2: Loading data in a loop that lead to N+1 roundtrips to the database
var groups = Context.ProductGroups.ToList();
var products = new List<Product>();

foreach (var group in groups)
{
   var product = Context.Products.FirstOrDefault(p => p.ProductGroupId == group.Id);
   products.Add(product);
}
```

===============================================================================
# Entity Framework Core 7
* -> although **EF 7 runs into N+1 Queries Problem** with **`Lazy Loading only`**, still, **`the problem is and will remain in our projects due to loops`**
* _nói đơn giản là vấn đề N+1 sẽ không đến từ bản thân EF 7 mà là do ta đã sử dụng loop (trực tiếp hoặc gián tiếp) không đúng cách dẫn đến database request hàng loạt_
* => the recommendations would be: **better code structure, reduced call stack depth, and check the number of executed SQL statements in integration tests** (**`IDbCommandInterceptor`**)

```cs
// EF 7 even translates GroupBy, which was impossible a few versions ago
var firstProducts = Context.Products
                  .GroupBy(p => p.ProductGroupId)
                  .Select(g => g.FirstOrDefault())
                  .ToList();
```
```sql
--  translates to:
SELECT *
FROM (
    SELECT [p].[ProductGroupId]
    FROM [Products] AS [p]
    GROUP BY [p].[ProductGroupId]
) AS [t]
LEFT JOIN (
    SELECT *
    FROM (
        SELECT
            *,
            ROW_NUMBER() OVER(PARTITION BY [p0].[ProductGroupId] ORDER BY [p0].[Id]) AS [row]
        FROM [Products] AS [p0]
    ) AS [t1]
    WHERE [t1].[row] <= 1
) AS [t0] ON [t].[ProductGroupId] = [t0].[ProductGroupId]
```

## Lazy Loading
* -> nothing has changed regarding "Lazy Loading", **the feature should be used with care**
```cs
// bad behavior: loading of all "Products" for 10 "ProductGroups" with the following LINQ query leads to 11 SQL statements
// 1 SQL statement for loading all "Products" and 10 for loading the "ProductGroups"
var lookup = Context.Products.ToLookup(p => p.Group.Name);
```
```sql
-- translate to:
// executed once
SELECT * FROM [Products] AS [p]

// excuted N times
SELECT [g].[Id], [g].[Name]
FROM [ProductGroups] AS [g]
WHERE [g].[Id] = @__p_0
```
```cs
// Solution: Eager Loading
var lookup = Context.Products
                    .Include(p => p.Group)
                    .ToLookup(p => p.Group.Name);

// Alternative: explicit selection of the ProductGroup-Name (this solution is more optimal because EF 7 loads only the name instead of the whole ProductGroup)
var lookup = Context.Products
                    .Select(p => new
                                 {
                                    Product = p,
                                    p.Group.Name
                                 })
                    .ToLookup(p => p.Name, p => p.Product);
```

## database request within loop
* -> đây nhiều khi là unintentionally, vì nhiều khi a query is executed **indirectly** within a loop
* => **the issue will be very hard to detect**

```cs
// Example:
// -> trường hợp mà các fragment is in different C# files;
// -> add a few other methods between the foreach-loop and the LINQ query Context.Prices that make the depth of the call stack and the complexity of the code

var products = Context.Products.ToList();
var prices = new List<Price>();

foreach (var product in products)
{
   var price = GetPrice(product.Id);
   prices.Add(price);
}

// ---------------

private Price GetPrice(int productId)
{
   // oversimplified

   return Context.Prices.FirstOrDefault(p => p.ProductId == productId);
}
```

```cs
// there are loops that don't look like loops
// i.e. they don't have the usual keywords like for, foreach, or while

var products = Context.Products.ToList();
var prices = products.Select(product => GetPrice(product.Id)).ToList();
```

# Previous version of EF
* -> Entity Framework Core 2 (EF 2) introduced a new feature that caused the "N+1 queries problem" more often and was more difficult to detect, so it was removed in the following version
* -> with Entity Framework Core 3 (EF 3) those queries usually raised an InvalidOperationException.

## Fetching a collection navigational property
```cs
// in EF 2.1, fetching a collection navigational property leads to 2 queries: one for "ProductGroups" and the other for the "Products"
var groups = Context.ProductGroups
          .Where(g => g.Name.Contains("Group"))
          .Select(g => new
          {
            ProductGroup = g,
            Products = g.Products.Where(p => p.Name.Contains("1")).ToList() // require .ToList() when fetching "Products"
          })
          .ToList();
```
```sql
-- in EF 3.1, we get just 1 SQL statement that fetches both the "ProductGroups" and "Products"
SELECT
    [p].[Id], [p].[Name], [p].[RowVersion],
    [t].[Id], [t].[GroupId], [t].[Name], [t].[RowVersion]
FROM [ProductGroups] AS [p]
LEFT JOIN
(
    SELECT [p0].[Id], [p0].[GroupId], [p0].[Name], [p0].[RowVersion]
    FROM [Products] AS [p0]
    WHERE CHARINDEX(N'1', [p0].[Name]) > 0
) AS [t] ON [p].[Id] = [t].[GroupId]
WHERE CHARINDEX(N'Group', [p].[Name]) > 0
ORDER BY [p].[Id], [t].[Id]
```

## Using "FirstOrDefault" inside "Select"
```cs
// in EF 2.1, when selecting the first "Product" for each "ProductGroup" using FirstOrDefault()
// EF 2.1 executes 1 SQL statement for loading N "ProductGroups" and N SQL statements for loading the "Products"
var groups = Context.ProductGroups
          .Where(g => g.Name.Contains("Group"))
          .Select(g => new
          {
            ProductGroup = g,
            Product = g.Products.FirstOrDefault()
          })
          .ToList();
```
```sql
-- in EF 3.1, it only executes just 1 SQL statement for loading all requested data
SELECT
    [p].[Id], [p].[Name], [p].[RowVersion],
    [t0].[Id], [t0].[GroupId], [t0].[Name], [t0].[RowVersion]
FROM [ProductGroups] AS [p]
LEFT JOIN
(
    SELECT [t].[Id], [t].[GroupId], [t].[Name], [t].[RowVersion]
    FROM
    (
        SELECT
            [p0].[Id], [p0].[GroupId], [p0].[Name], [p0].[RowVersion],
            ROW_NUMBER() OVER(PARTITION BY [p0].[GroupId] ORDER BY [p0].[Id]) AS [row]
        FROM [Products] AS [p0]
    ) AS [t]
    WHERE [t].[row] <= 1
) AS [t0] ON [p].[Id] = [t0].[GroupId]
WHERE CHARINDEX(N'Group', [p].[Name]) > 0
```

## Usage of "FirstOrDefault" along with "GroupBy"
* -> in EF 2.1, the LINQ query below that is **`not translatable to SQL, EF wil switched to client-side evaluation`** which could lead to **`bad performance`** if it was overlooked due to the fact that **the whole table "Products" is fetched into memory**
* -> for Entity Framework Core 3.0/3.1, GroupBy has very limited support and with the query below we get an **`InvalidOperationException`** and we now know we have to do something about it (however, this inevitably causes the so-called **Cartesian Explosion Problem**)

```cs
var firstProducts = Context.Products
                  .GroupBy(p => p.GroupId)
                  .Select(g => g.FirstOrDefault())
                  .ToList();
```

===============================================================================
## The N+1 problem in Entity Framework (EF)
* -> occurs when **`querying a collection of entities along with their related data`**, leading to multiple database queries instead of a single optimized one

```cs
// -> load data from a table "ProductGroups" along with its related data "Products" having a 'one-to-many' relationship
// -> this may execute 1 SQL statement to load N ProductGroups and after that N SQL statements to load Products for each ProductGroup separately
// -> hence the name: N+1 Queries
Context.ProductGroups
          .Select(g => new
          {
            ProductGroup = g,
            Products = g.Products
          })
          .ToList();
```

## Use Eager Loading (Include)
Use the .Include() method to load related entities in a single query.

```cs
var orders = _context.Orders
    .Include(o => o.Customer)
    .Include(o => o.OrderItems)
    .ThenInclude(oi => oi.Product)
    .ToList();
```
This ensures that EF retrieves all related entities in one SQL query instead of multiple queries.

## Use Projection (Select)
Instead of loading entire entities, fetch only the necessary fields to optimize performance.

```cs
var orders = _context.Orders
    .Select(o => new 
    {
        o.Id,
        CustomerName = o.Customer.Name,
        OrderItems = o.OrderItems.Select(oi => new 
        {
            oi.Product.Name,
            oi.Quantity
        })
    })
    .ToList();
```

This avoids loading unnecessary columns and prevents EF from tracking unwanted entities.

## Use Explicit Loading for Large Data
If eager loading is too expensive, use explicit loading to fetch related entities when needed.

```cs
var order = _context.Orders.FirstOrDefault(o => o.Id == orderId);
_context.Entry(order).Collection(o => o.OrderItems).Load();
```

This avoids unnecessary joins and loads related data only when required.

## Use Batch Queries with AsSplitQuery (EF Core 5+)
EF Core 5+ introduced AsSplitQuery(), which improves performance when dealing with multiple one-to-many relationships.

```cs
var orders = _context.Orders
    .Include(o => o.Customer)
    .Include(o => o.OrderItems)
    .AsSplitQuery()
    .ToList();
```

This executes multiple queries efficiently instead of a single massive join, reducing data duplication.

## Use Lazy Loading (If Necessary) – But Be Cautious
Lazy loading loads related data only when accessed. However, it can lead to unexpected N+1 queries if not managed properly.
Enable Lazy Loading:

```cs
public class Order
{
    public int Id { get; set; }
    
    public virtual Customer Customer { get; set; }  // Virtual enables lazy loading
}
```

Lazy loading works, but use it cautiously, as accessing a related entity inside a loop can trigger multiple queries.

## Use Raw SQL Queries (FromSqlInterpolated) for Performance-Critical Cases
For complex queries, use raw SQL to fetch only necessary data efficiently.

```cs
var orders = _context.Orders
    .FromSqlInterpolated($"SELECT * FROM Orders WHERE CustomerId = {customerId}")
    .ToList();
```

Use this only when needed to optimize query execution.

## Summary: Best Practices
✔ Use .Include() for eager loading when you need related data.
✔ Use .Select() to fetch only necessary fields.
✔ Use AsSplitQuery() for multiple one-to-many relationships.
✔ Avoid lazy loading unless explicitly required.
✔ Optimize performance with raw SQL when needed.

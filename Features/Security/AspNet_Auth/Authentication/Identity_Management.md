> https://learn.microsoft.com/en-us/aspnet/core/security/identity-management-solutions?view=aspnetcore-6.0

===================================================================
# Identity management solution
* -> this is one of core functionality of IAM system (_xem `Features\Security\Auth\IAM\Overview.md` để hiểu thêm_)
* -> _Identity management solutions_ are built to **`handle the requirements of authentication and authorization-related tasks`**

## Table of 'Identity management solutions' for .NET web apps
* -> https://learn.microsoft.com/en-us/aspnet/core/security/identity-management-solutions?view=aspnetcore-8.0
* -> về cơ bản sẽ bao gồm: **`ASP.NET Core Identity`**, **`Auth0`**, **`Duende IdentityServer`**, **`Keycloak`**, **`Microsoft Entra ID`**, **`Okta`**, **`OpenIddict`**

* -> table lists both **open source** and **commercial** solutions that offer features and capabilities to **`manage user authentication, authorization, and user identity`** within an app
* -> details such as **license type**, **website**, and **documentation** that is **`specific to ASP.NET Core integration`**
* ->  includes options for apps that are: **`Container-based`**, **`Self-hosted`**, **`Managed`** (_such as cloud-based services like Microsoft Entra_)

===================================================================
> for most scenarios, the basic identity management with `ASP.NET Core Identity` may be the only provider needed
> however, in other scenarios a server or service that manages authentication and identity may be beneficial

# Basic identity management with 'ASP.NET Core Identity'
* -> **ASP.NET Core** ships with a **`built-in authentication provider: ASP.NET Core Identity`**
* -> the provider includes the **`APIs`**, **`UI`**, and **`backend database`** configuration 
* -> to support **`managing user identities`**, **`storing user credentials`**, and **`granting or revoking permissions`**
* -> other features it supports include: **External logins**, **Two-factor authentication (2FA)**, **Password management**, **Account lockout and reactivation**, **Authenticator apps**

===================================================================
# Determine if an OIDC server is needed

## Cookie
* -> web apps require a way to **remember past actions** because the **`web, by default, is stateless`** 
* -> otherwise, **users** would be **`forced to enter their credentials every time`** they **navigated to a new page**
* -> the **common solution for remembering state** is **`cookies`**, a browser-based mechanism for storing data

* -> the **web server sends the initial cookie**, then the **browser stores it** and **sends it back with each request**
* -> this is **`done automatically`** without the need for the developer to write any code
* -> Cookies are easy to use and built into the browser **`but are designed for use within a single website or web domain`**
* -> the **default solution** that is **built into ASP.NET Core** uses **`cookie-based authentication`**

## Token
* -> _Tokens_ are **`containers with metadata`** that are **explicitly passed** through the **headers or body of HTTP requests**
* -> the **main advantage of tokens over cookies** is that they are **`not tied to a specific app or domain`**

* -> instead, tokens are usually **signed with asymmetric cryptography**
* _For example, `OIDC servers` issue tokens with `information about identity` using the `JSON Web Token (JWT)`_ format which includes `signing`_

* -> **Asymmetric cryptography** uses a combination of a **`private key known only to the signer`**, and **`a public key which everyone can know`**; _Tokens may also be encrypted_
* -> the **`signed token can't be tampered with due to the private key`**
* -> the **public key** makes it possible to validate the token to **`ensure it hasn't been changed`** and guarantees that it was **`generated by the entity holding the private key`**

## OIDC server
* -> the **main disadvantage to using tokens** is that they **`require a service (typically an OIDC server)`** to **`both issue and provide validation for tokens`**
* -> the service must be installed, configured, and maintained - maybe a **self-host, installed or container, OIDC Server** or **Cloud or managed OIDC Server**

## Use case

### "expose web-based APIs" that are consumed by different types of client apps
* -> a **common reason an OIDC server** is required is for **`applications that expose web-based APIs`** that are consumed by other apps 
* -> _for exposed web-based APIs_, client UIs such as **Single Page Applications (SPA)**, **mobile clients**, and **desktop clients** are **`considered to be part of the same app`**
* => if **apps other than our web app or any client UIs** must **`make a secure API call to our app`**, we'll likely want to use **`tokens`**

* -> if we only have **`client UIs`** (_tức là không có backend services hoặc appliction interact with our API_), **ASP.NET Core Identity** provides the **`option to acquire a token during authentication`**
* -> the **authentication token issued by ASP.NET Core Identity** can be **`used by mobile and desktop clients`**; however **`Cookies are preferred over tokens`** for both security and simplicity.
* -> **ASP.NET Core Identity** isn't suitable for **`managing access from third-party apps`**

### Single Sign On
* -> another reason an _OIDC server is required_ is for **`sharing sign-ins`** with other apps - commonly referred to as **single sign on**
* ->, this feature enables **users** to **`sign in once with a web app's form`** and **`use the resulting credentials to authenticate with other apps`** without having to sign-in again or choose a different password

* -> for **apps that don't share logins with other apps**, the simplest way to quickly secure an app is to **`use the built-in ASP.NET Core Identity provider`**
* -> otherwise, **an OIDC server** provided by **a third-party identity management solution** is **`needed`**
* -> OIDC servers are available as **`products we install on our server, called self-host`**, **`Containers run in a host like Docker`**, **`Web-based services we integrate with to manage identity`**

## Disconnected scenarios
* -> many solutions (_such as "Microsoft Entra ID"_), are **cloud-based** and **`require an Internet connection to work`**
* -> if our environment doesn't allow Internet connectivity, we won't be able to use the service

* -> **`ASP.NET Core Identity`** works **perfectly well in disconnected scenarios**
* -> such as **`app can't access the Internet`**, **`app must still function on the local network even if the Internet is disconnected`**

* -> if we **`require a full OIDC server for a disconnected scenario`**, choose one of the following options:
* -> a solution that allows us to **`install and run the service on our own machines`** or **`run the authentication service locally as a container`**

===================================================================
# Decide where user data (such as user sign-ins data) are stored
* -> many developers choose **`external, cloud-based services`** like **Microsoft Entra ID** to **manage identity**
* -> a cloud-based service provider takes on the responsibilities of **securely storing data**
* -> keeps the software **up to date** with the latest security patches and releases.
* -> complies with **privacy regulations**

* -> others prefer to store data on their **`own servers`** due to **regulations, compliance, policy,...**
* -> if the data is stored on our servers, we'll most likely need to choose an **`installable or container-based solution`**

===================================================================
# Identity management solutions for .NET web apps